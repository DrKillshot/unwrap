"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[742],{485:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=n(4848),i=n(8453);const s={title:"Either<Ok, Error>",sidebar_label:"Either",sidebar_position:2},o=void 0,a={id:"monads/either",title:"Either<Ok, Error>",description:"The Either monad can hold two types of values: an Ok(value) value and an Error(error) value. The Either monad is typically use to replace exceptions in the codebase and make each method more explicit and declarative in its Either.",source:"@site/docs/monads/either.md",sourceDirName:"monads",slug:"/monads/either",permalink:"/unwrap/docs/monads/either",draft:!1,unlisted:!1,editUrl:"https://github.com/DrKillshot/unwrap/docs/monads/either.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Either<Ok, Error>",sidebar_label:"Either",sidebar_position:2},sidebar:"docs",previous:{title:"Maybe",permalink:"/unwrap/docs/monads/maybe"},next:{title:"IO",permalink:"/unwrap/docs/monads/io"}},l={},c=[{value:"Either constructors",id:"either-constructors",level:2},{value:"Methods",id:"methods",level:2},{value:".map(fn)",id:"mapfn",level:3},{value:".mapError(fn)",id:"maperrorfn",level:3},{value:".flatMap(fn)",id:"flatmapfn",level:3},{value:".swap()",id:"swap",level:3},{value:".isOk()",id:"isok",level:3},{value:".isError()",id:"iserror",level:3},{value:".recover(defaultValue)",id:"recoverdefaultvalue",level:3},{value:".ifOk(fn)",id:"ifokfn",level:3},{value:".ifError(fn)",id:"iferrorfn",level:3},{value:".match(matcher)",id:"matchmatcher",level:3},{value:".toMaybe()",id:"tomaybe",level:3},{value:".unwrap()",id:"unwrap",level:3},{value:".unwrapError()",id:"unwraperror",level:3},{value:".fromThrowable(fn)",id:"fromthrowablefn",level:3}];function h(e){const r={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"Either"})," monad can hold two types of values: an ",(0,t.jsx)(r.code,{children:"Ok(value)"})," value and an ",(0,t.jsx)(r.code,{children:"Error(error)"})," value. The ",(0,t.jsx)(r.code,{children:"Either"})," monad is typically use to ",(0,t.jsx)(r.strong,{children:"replace exceptions"})," in the codebase and make each method more explicit and declarative in its ",(0,t.jsx)(r.code,{children:"Either"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"either-constructors",children:"Either constructors"}),"\n",(0,t.jsxs)(r.p,{children:["Just like ",(0,t.jsx)(r.code,{children:"Maybe"}),", the ",(0,t.jsx)(r.code,{children:"Either"})," monad can be instantiated with specific constructors. In this case the ",(0,t.jsx)(r.code,{children:"Ok(value)"})," and ",(0,t.jsx)(r.code,{children:"Error(error)"})," constructor:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const anOk = Either.Ok(10)\nconst anError = Either.Error("Something went wrong here!")\n\n// You can also force types in the constructors\nconst anOk = Either<number>(10)\nconst anError<string> = Either<string>("Something went wrong here!")\n'})}),"\n",(0,t.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"Either"})," monad exposes several methods for value manipulation"]}),"\n",(0,t.jsx)(r.h3,{id:"mapfn",children:".map(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.map<T>(fn: (input: O) => T): Either<T, E> | Either<O, E>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Transforms the error inside the ",(0,t.jsx)(r.code,{children:"Either"})," if it is ",(0,t.jsx)(r.code,{children:"Ok"}),", otherwise does nothing."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:"const Either = Either.Ok(10);\nconst newEither = Either.map(x => x * 2); // Ok(20)\n\nconst error = Either.Error(10)\nconst newError = Either.map(x => x * 2) // Error(10)\n"})}),"\n",(0,t.jsx)(r.h3,{id:"maperrorfn",children:".mapError(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.map<T>(fn: (input: O) => T): Either<O, T>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Transforms the value inside the ",(0,t.jsx)(r.code,{children:"Either"})," if it is ",(0,t.jsx)(r.code,{children:"Ok"}),", otherwise does nothing."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const error = Either.Error("error");\nconst newError = error.mapError(err => `new ${err}`); // Error("new error")\n\nconst ok = Either.Ok("OK!")\nconst newOk = ok.mapError(err => `new ${err}`) // Ok("OK!")\n'})}),"\n",(0,t.jsx)(r.h3,{id:"flatmapfn",children:".flatMap(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.flatMap<T, R>(fn: (input: O) => Either<T, R>): Either<T, E | R>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Transforms the value inside the ",(0,t.jsx)(r.code,{children:"Either"})," into another ",(0,t.jsx)(r.code,{children:"Either"})," and flattens the result. If the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Error"}),", the original type is returned unchanged."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst flatMappedValue = okValue.flatMap(x => Either.Ok(x + 10)); // Ok(15)\n\nconst errorValue = Either.Error("Something went wrong");\nconst flatMappedError = errorValue.flatMap(x => Either.Ok(x + 10)); // Error("Something went wrong")\n'})}),"\n",(0,t.jsx)(r.h3,{id:"swap",children:".swap()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.swap()\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Swaps the ",(0,t.jsx)(r.code,{children:"Ok"})," and ",(0,t.jsx)(r.code,{children:"Error"})," values. If the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Ok"}),", it becomes ",(0,t.jsx)(r.code,{children:"Error"}),", and if it is ",(0,t.jsx)(r.code,{children:"Error"}),", it becomes ",(0,t.jsx)(r.code,{children:"Ok"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst swappedValue = okValue.swap(); // Error(5)\n\nconst errorValue = Either.Error("Something went wrong");\nconst swappedError = errorValue.swap(); // Ok("Something went wrong")\n'})}),"\n",(0,t.jsx)(r.h3,{id:"isok",children:".isOk()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O, E>.isOk(): this is Ok<O>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Checks if the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Ok"}),". Returns true if it is, otherwise returns false."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:'const okValue = Either.Ok(5);\nconsole.log(okValue.isOk()); // true\n\nconst errorValue = Either.Error("Something went wrong");\nconsole.log(errorValue.isOk()); // false\n'})}),"\n",(0,t.jsx)(r.h3,{id:"iserror",children:".isError()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.isError(): this is Error<E>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Checks if the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Error"}),". Returns true if it is, otherwise returns false."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconsole.log(okValue.isError()); // false\n\nconst errorValue = Either.Error("Something went wrong");\nconsole.log(errorValue.isError()); // true\n'})}),"\n",(0,t.jsx)(r.h3,{id:"recoverdefaultvalue",children:".recover(defaultValue)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<E,O>.recover<T>(defaultValue: T): Either<O, E> | Either<T, E>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Recovers from an ",(0,t.jsx)(r.code,{children:"Error"})," by providing a default value. If the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Error"}),", it returns a new ",(0,t.jsx)(r.code,{children:"Either"})," with the default value as ",(0,t.jsx)(r.code,{children:"Ok"}),". If it is ",(0,t.jsx)(r.code,{children:"Ok"}),", the original ",(0,t.jsx)(r.code,{children:"Either"})," is returned unchanged."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst recoveredOk = okValue.recover(10); // Ok(5)\n\nconst errorValue = Either.Error("Something went wrong");\nconst recoveredError = errorValue.recover(10); // Ok(10)\n'})}),"\n",(0,t.jsx)(r.h3,{id:"ifokfn",children:".ifOk(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.ifOk(fn: (input: O) => void): Either<O, E>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Applies a function to the value inside the ",(0,t.jsx)(r.code,{children:"Either"})," if it is ",(0,t.jsx)(r.code,{children:"Ok"}),", without changing the ",(0,t.jsx)(r.code,{children:"Either"}),". If it is ",(0,t.jsx)(r.code,{children:"Error"}),", the original ",(0,t.jsx)(r.code,{children:"Either"})," is returned unchanged."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst tappedValue = okValue.ifOk(console.log); // Logs: 5, returns Ok(5)\n\nconst errorValue = Either.Error("Something went wrong");\nconst tappedError = errorValue.ifOk(console.log); // No log, returns Error("Something went wrong")\n'})}),"\n",(0,t.jsx)(r.h3,{id:"iferrorfn",children:".ifError(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.ifError(fn: (input: E) => void): Either<O, E>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Applies a function to the error inside the ",(0,t.jsx)(r.code,{children:"Either"})," if it is ",(0,t.jsx)(r.code,{children:"Error"}),", without changing the ",(0,t.jsx)(r.code,{children:"Either"}),". If it is ",(0,t.jsx)(r.code,{children:"Ok"}),", the original ",(0,t.jsx)(r.code,{children:"Either"})," is returned unchanged."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const errorValue = Either.Error("Something went wrong");\nconst tappedError = errorValue.ifError(console.log); // Logs: Something went wrong, returns Error("Something went wrong")\n\nconst okValue = Either.Ok(5);\nconst tappedOkValue = okValue.ifError(console.log); // No log, returns Ok(5)\n'})}),"\n",(0,t.jsx)(r.h3,{id:"matchmatcher",children:".match(matcher)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<E,O>.match<T, R>(matcher: { Ok: (value: O) => T, Error: (value: E) => R }): T | R;\nEither<E,O>.match<T, R>(matcher: { Ok: (value: O) => T, Error: R }): T | R;\nEither<E,O>.match<T, R>(matcher: { Ok: T, Error: (value: E) => R }): T | R;\nEither<E,O>.match<T, R>(matcher: { Ok: T, Error: R }): T | R;\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Matches the ",(0,t.jsx)(r.code,{children:"Either"})," to a function or value based on its state (",(0,t.jsx)(r.code,{children:"Ok"})," or ",(0,t.jsx)(r.code,{children:"Error"}),"). This allows handling both states of the ",(0,t.jsx)(r.code,{children:"Either"})," in a single call."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst matchedOk = okValue.match({ Ok: value => value * 2, Error: err => `Error: ${err}` }); // 10\n\nconst errorValue = Either.Error("Something went wrong");\nconst matchedError = errorValue.match({ Ok: value => value * 2, Error: err => `Error: ${err}` }); // "Error: Something went wrong"\n'})}),"\n",(0,t.jsx)(r.h3,{id:"tomaybe",children:".toMaybe()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.toMaybe(): Maybe<O>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Converts the ",(0,t.jsx)(r.code,{children:"Either"})," to a ",(0,t.jsx)(r.code,{children:"Maybe"})," monad. If the ",(0,t.jsx)(r.code,{children:"Either"})," is ",(0,t.jsx)(r.code,{children:"Ok"}),", the ",(0,t.jsx)(r.code,{children:"Maybe"})," contains the value. If it is ",(0,t.jsx)(r.code,{children:"Error"}),", it returns ",(0,t.jsx)(r.code,{children:"Maybe.None()"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'const okValue = Either.Ok(5);\nconst maybeValue = okValue.toMaybe(); // Some(5)\n\nconst errorValue = Either.Error("Something went wrong");\nconst maybeNone = errorValue.toMaybe(); // None\n'})}),"\n",(0,t.jsx)(r.h3,{id:"unwrap",children:".unwrap()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.unwrap()\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Returns the value inside the ",(0,t.jsx)(r.code,{children:"Either"})," if the type is ",(0,t.jsx)(r.code,{children:"Ok"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:"function fetchUsers(): Either<User, string>\n\nconst users = fetchUsers();\nconst users.unwrap() // Won't compile\n\nif(users.isOk()) {\n    users.unwrap() // Returns the User inside the Either\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"unwraperror",children:".unwrapError()"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.unwrapError()\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Returns the value inside the ",(0,t.jsx)(r.code,{children:"Either"})," if the type is ",(0,t.jsx)(r.code,{children:"Error"})]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:"function fetchUsers(): Either<User, string>\n\nconst users = fetchUsers();\nconst users.unwrapError() // Won't compile\n\nif(users.isError()) {\n    users.unwrapError() // Returns the string inside the Either\n}\n"})}),"\n",(0,t.jsx)(r.h3,{id:"fromthrowablefn",children:".fromThrowable(fn)"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Signature"',children:"Either<O,E>.fromThrowable<T>(fn: () => T): Error<unknown> | Ok<T>\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Returns an ",(0,t.jsx)(r.code,{children:"Ok"})," type with the value returned by the function and an ",(0,t.jsx)(r.code,{children:"Error"})," if the function throws."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="Examples"',children:'function divide(a: number, b: number): number {\n    if (b === 0) {\n        throw "Cannot divide by zero!"\n    }else {\n        return a/b\n    }\n}\n\nEither.fromThrowable(() => divide(10, 2)) // Ok<5>\n\nEither.fromThrowable(() => divide(10, 0)) // Error<"Cannot divide by zero!">\n'})})]})}function d(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var t=n(6540);const i={},s=t.createContext(i);function o(e){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:r},e.children)}}}]);